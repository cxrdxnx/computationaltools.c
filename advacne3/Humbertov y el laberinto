/*******************************************************************/
/*******************************************************************/
/* Institution: Universidad Tecnologica de Pereira.                */
/* Country: Colombia (south america).                              */
/* Course: Estructura de Datos (Data Structure).                   */
/* Group: 05.                                                      */
/* Professor: Hugo Humberto Morales P.                             */
/* Semester: February/June                                         */
/* Date: May 26th, 2025.                                           */
/* Implementation: DFS's Algorithm on mazes.                       */
/* Topics: * Depth-First Search (DFS).                             */
/*         * Mazes.                                                */
/*                                                                 */
/* NOTES: * Implementation of DFS's Algorithm on mazes.            */
/*******************************************************************/
/*******************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define MAXW 100
#define MAXH 100
#define NIL -1
#define BLACK 0
#define GRAY 1
#define WHITE 2
#define myInfinite 2147483647

struct cell {
    int coord_x;
    int coord_y;
};

void ReadMaze(char Maze[][MAXW + 1], int H, int W)
{
    int idRow, idColumn;
    char line[MAXW + 1];

    for(idRow = 1; idRow <= H; idRow++)
    {
        scanf("%s", line);
        for(idColumn = 1; idColumn <= W; idColumn++)
            Maze[idRow][idColumn] = line[idColumn - 1];
    }
}

void assignMovements(struct cell arrayMov[])
{
    arrayMov[0].coord_x = 0;
    arrayMov[0].coord_y = 0;

    arrayMov[1].coord_x = 0;
    arrayMov[1].coord_y = -1;

    arrayMov[2].coord_x = 0;
    arrayMov[2].coord_y = 1;

    arrayMov[3].coord_x = -1;
    arrayMov[3].coord_y = 0;

    arrayMov[4].coord_x = 1;
    arrayMov[4].coord_y = 0;
}

/******************************************************/
/************** BFS FOR REGIONS (NO STACK) ************/
/******************************************************/
int BFS_Region(char Maze[][MAXW + 1],
               int H, int W,
               struct cell start,
               int color[][MAXW + 1],
               struct cell pi[][MAXW + 1],
               int regionID[][MAXW + 1],
               int currentRegionID)
{
    static struct cell queue[(MAXH * MAXW) + 5];
    int head = 1, tail = 1;
    int size = 0;

    struct cell mov[5];
    assignMovements(mov);

    queue[tail++] = start;
    color[start.coord_y][start.coord_x] = GRAY;
    regionID[start.coord_y][start.coord_x] = currentRegionID;

    while(head < tail)
    {
        struct cell u = queue[head++];
        size++;

        for(int k = 1; k <= 4; k++)
        {
            struct cell v;
            v.coord_x = u.coord_x + mov[k].coord_x;
            v.coord_y = u.coord_y + mov[k].coord_y;

            if(v.coord_x >= 1 && v.coord_x <= W &&
               v.coord_y >= 1 && v.coord_y <= H &&
               Maze[v.coord_y][v.coord_x] == '.' &&
               color[v.coord_y][v.coord_x] == WHITE)
            {
                color[v.coord_y][v.coord_x] = GRAY;
                regionID[v.coord_y][v.coord_x] = currentRegionID;
                pi[v.coord_y][v.coord_x] = u;
                queue[tail++] = v;
            }
        }

        color[u.coord_y][u.coord_x] = BLACK;
    }

    return size;
}

/******************************************************/
/**************** BFS NORMAL PARA D *******************/
/******************************************************/
void BFS_Maze(char Maze[][MAXW + 1], int W, int H, struct cell s,
              int color[][MAXW + 1], int d[][MAXW + 1],
              struct cell pi[][MAXW + 1])
{
    int idHead = 1, idTail = 1;
    int idRow, idColumn;
    int idMovement;

    struct cell NilFather, Q[(MAXH * MAXW) + 5], u, v, movements[5];

    assignMovements(movements);

    NilFather.coord_x = NIL;
    NilFather.coord_y = NIL;

    for(idRow = 1; idRow <= H; idRow++)
        for(idColumn = 1; idColumn <= W; idColumn++)
        {
            color[idRow][idColumn] = WHITE;
            d[idRow][idColumn] = myInfinite;
            pi[idRow][idColumn] = NilFather;
        }

    color[s.coord_y][s.coord_x] = GRAY;
    d[s.coord_y][s.coord_x] = 0;

    Q[idTail++] = s;

    while(idHead < idTail)
    {
        u = Q[idHead++];
        for(idMovement = 1; idMovement <= 4; idMovement++)
        {
            v.coord_x = u.coord_x + movements[idMovement].coord_x;
            v.coord_y = u.coord_y + movements[idMovement].coord_y;

            if((v.coord_x >= 1 && v.coord_x <= W) &&
               (v.coord_y >= 1 && v.coord_y <= H) &&
               (Maze[v.coord_y][v.coord_x] == '.') &&
               (color[v.coord_y][v.coord_x] == WHITE))
            {
                color[v.coord_y][v.coord_x] = GRAY;
                d[v.coord_y][v.coord_x] = d[u.coord_y][u.coord_x] + 1;
                pi[v.coord_y][v.coord_x] = u;

                Q[idTail++] = v;
            }
        }
        color[u.coord_y][u.coord_x] = BLACK;
    }
}

int solverBFS(char Maze[][MAXW + 1], int H, int W,
              int regionID[][MAXW + 1], int targetRegion,
              struct cell startCell)
{
    int i, j;

    int color[MAXH + 1][MAXW + 1], d[MAXH + 1][MAXW + 1];
    struct cell pi[MAXH + 1][MAXW + 1];

    BFS_Maze(Maze, W, H, startCell, color, d, pi);

    struct cell farthest1 = startCell;
    int maxDist1 = 0;

    for(i = 1; i <= H; i++)
        for(j = 1; j <= W; j++)
            if(regionID[i][j] == targetRegion && d[i][j] != myInfinite && d[i][j] > maxDist1)
            {
                maxDist1 = d[i][j];
                farthest1.coord_x = j;
                farthest1.coord_y = i;
            }

    BFS_Maze(Maze, W, H, farthest1, color, d, pi);

    int maxDist2 = 0;

    for(i = 1; i <= H; i++)
        for(j = 1; j <= W; j++)
            if(regionID[i][j] == targetRegion && d[i][j] != myInfinite && d[i][j] > maxDist2)
                maxDist2 = d[i][j];

    return maxDist2;
}

/******************************************************/
/******************* MAIN DFS_MAZE ********************/
/******************************************************/
void DFS_Maze(char Maze[][MAXW + 1],
              int H, int W,
              int color[][MAXW + 1],
              int d[][MAXW + 1],
              int f[][MAXW + 1],
              struct cell pi[][MAXW + 1],
              int idCase)
{
    int idRow, idColumn;

    int regionID[MAXH + 1][MAXW + 1];
    for(idRow = 1; idRow <= H; idRow++)
        for(idColumn = 1; idColumn <= W; idColumn++)
            regionID[idRow][idColumn] = -1;

    for(idRow = 1; idRow <= H; idRow++)
        for(idColumn = 1; idColumn <= W; idColumn++)
        {
            color[idRow][idColumn] = WHITE;
            d[idRow][idColumn] = myInfinite;
            f[idRow][idColumn] = myInfinite;
            pi[idRow][idColumn].coord_x = NIL;
            pi[idRow][idColumn].coord_y = NIL;
        }

    int numRegiones = 0;
    int maxSize = 0;
    int maxRegionID = -1;
    struct cell maxRegionStart;

    for(idRow = 1; idRow <= H; idRow++)
    {
        for(idColumn = 1; idColumn <= W; idColumn++)
        {
            if(Maze[idRow][idColumn] == '.' && color[idRow][idColumn] == WHITE)
            {
                struct cell U;
                U.coord_x = idColumn;
                U.coord_y = idRow;

                int size = BFS_Region(Maze, H, W, U, color, pi, regionID, numRegiones);
                if(size > maxSize)
                {
                    maxSize = size;
                    maxRegionID = numRegiones;
                    maxRegionStart = U;
                }
                numRegiones++;
            }
        }
    }

    int D = 0;
    if(maxSize > 1)
        D = solverBFS(Maze, H, W, regionID, maxRegionID, maxRegionStart);

    printf("Case %d: %d %d %d\n", idCase, numRegiones, maxSize, D);
}

void solver(char Maze[][MAXW + 1], int H, int W, int idCase)
{
    int color[MAXH + 1][MAXW + 1];
    int d[MAXH + 1][MAXW + 1];
    int f[MAXH + 1][MAXW + 1];
    struct cell pi[MAXH + 1][MAXW + 1];

    DFS_Maze(Maze, H, W, color, d, f, pi, idCase);
}

int main()
{
    char Maze[MAXH + 1][MAXW + 1];
    int totalCases, idCase, H, W;

    scanf("%d", &totalCases);

    for(idCase = 1; idCase <= totalCases; idCase++)
    {
        scanf("%d %d", &H, &W);
        ReadMaze(Maze, H, W);
        solver(Maze, H, W, idCase);
    }

    return 0;
}
